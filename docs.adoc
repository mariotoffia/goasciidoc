= Go Asciidoc Document Generator
:author_name: Mario Toffia
:author: {author_name}
:author_email: mario.toffia@xy.net
:email: {author_email}
:source-highlighter: highlightjs
:icons: font
:imagesdir: ../meta/assets
:homepage: https://github.com/mariotoffia/goasciidoc
:kroki-default-format: svg
:doctype: book

== Package github.com/mariotoffia/goasciidoc

package main contains the one and only binary to run goasciidoc

=== Imports
[source, go]
----
import (
    "fmt"
    "os"
    "strings"
    "testing"
    "github.com/alexflint/go-arg"
    "github.com/mariotoffia/goasciidoc/asciidoc"
    "github.com/stretchr/testify/assert"
    "io/ioutil"
)
----

== Structs

=== args
[source, go]
----
type args struct {
    Out               string
    StdOut            bool
    Module            string
    Internal          bool
    Private           bool
    Test              bool
    NoIndex           bool
    NoToc             bool
    IndexConfig       string
    Overrides         []string
    Paths             []string
    ListTemplates     bool
    OutputTemplate    string
    PackageDoc        []string
}
----



==== Out string


==== StdOut bool


==== Module string


==== Internal bool


==== Private bool


==== Test bool


==== NoIndex bool


==== NoToc bool


==== IndexConfig string


==== Overrides []string


==== Paths []string


==== ListTemplates bool


==== OutputTemplate string


==== PackageDoc []string



==== Receivers

===== Version
[source, go]
----
func (args) Version() string
----






== Functions


=== main
[source, go]
----
func main()
----




=== runner
[source, go]
----
func runner(args args)
----




=== TestOverridePackageTemplate
[source, go]
----
func TestOverridePackageTemplate(t *testing.T)
----





== Package github.com/mariotoffia/goasciidoc/asciidoc


=== Imports
[source, go]
----
import (
    "bytes"
    "fmt"
    "io"
    "os"
    "strings"
    "testing"
    "encoding/json"
    "github.com/mariotoffia/goasciidoc/goparser"
    "github.com/mariotoffia/goasciidoc/internal/utils"
    "github.com/stretchr/testify/assert"
    "io/ioutil"
    "os/user"
    "path/filepath"
    "text/tabwriter"
    "text/template"
)
----

== Structs

=== Producer
[source, go]
----
type Producer struct {
    parseconfig      goparser.ParseConfig
    paths            []string
    outfile          string
    index            bool
    indexconfig      string
    overrides        map[string]string
    writer           io.Writer
    toc              bool
    overviewpaths    []string
}
----

Producer parses go code and produces asciidoc documentation.

==== parseconfig goparser.ParseConfig
parseconfig is the configuration that it uses to invoke
the parser with.

==== paths []string
paths is files and directories to include.

==== outfile string
outfile is the file to write the generated documentation onto

==== index bool
index determines if it will render index as header for all
rendered documents. If inclusion, this might be a good idea
not to render index. Default is true.

==== indexconfig string
indexconfig is a JSON document to override the default IndexConfig
when rendering the index template

==== overrides map[string]string
overrides is the template overrides that is passed to the template engine.

==== writer io.Writer
writer is a fixed custom writer that *all* gets written to.

==== toc bool
toc enables or disables the table of contents if index is set to true
default is true

==== overviewpaths []string
overviewpaths is which paths to search for overview ascii doc document.
It defaults to overview.adoc, _design/overview.adoc.


==== Receivers

===== StdOut
[source, go]
----
func (p *Producer) StdOut() *Producer
----

StdOut writes to stdout instead onto filesystem.

===== Writer
[source, go]
----
func (p *Producer) Writer(w io.Writer) *Producer
----

Writer sets a custom writer where *everything* gets written to.

===== PackageDoc
[source, go]
----
func (p *Producer) PackageDoc(filepath ...string) *Producer
----

PackageDoc adds a relative, each package, filepath to search for overview package asciidoc.

For example _design/package.adoc will make goasciidoc to search relative each package path
for this particular folder and file.

===== OverrideFilePath
[source, go]
----
func (p *Producer) OverrideFilePath(name, path string) *Producer
----

OverrideFilePath will use another template instead of a built-in default
for the particular name (see TemplateType for valid template names)
This is loaded from the in param path.

===== Override
[source, go]
----
func (p *Producer) Override(name, template string) *Producer
----

Override will use another template instead of a built-in default
for the particular name (see TemplateType for valid template names)

===== Outfile
[source, go]
----
func (p *Producer) Outfile(path string) *Producer
----

Outfile sets a file to write to

===== NoIndex
[source, go]
----
func (p *Producer) NoIndex() *Producer
----

NoIndex specifies that the generated asciidoctor document will not have
a index header. This is good for inclusion where a header is already present.

===== NoToc
[source, go]
----
func (p *Producer) NoToc() *Producer
----

NoToc disables the table of contents if index is enabled. Default
is when index is enabled a table of contents is produced.

===== IndexConfig
[source, go]
----
func (p *Producer) IndexConfig(overrides string) *Producer
----

IndexConfig will configures using SON properties and hence it
will override the default IndexConfig configuration. If no overide,
just pass an empty string.

===== Module
[source, go]
----
func (p *Producer) Module(path string) *Producer
----

Module directs the producer to pick up module from path.

path may be a directory or a full path to go.mod. If "" it
will use current directory.

===== Include
[source, go]
----
func (p *Producer) Include(path ...string) *Producer
----

Include adds one or more directory or files in any combination. The producer
will sort out which are directories and which are filepaths.

If filepath, it will not do any type of checking and will blindly think it is a
valid go file.

===== IncludeTest
[source, go]
----
func (p *Producer) IncludeTest() *Producer
----

IncludeTest will create documentation for test files as well.

===== IncludeInternal
[source, go]
----
func (p *Producer) IncludeInternal() *Producer
----

IncludeInternal will include internal folder source files.

===== IncludeUnderScoreDirectories
[source, go]
----
func (p *Producer) IncludeUnderScoreDirectories() *Producer
----

IncludeUnderScoreDirectories will include files that resides below
directories starting with underscore.

===== CreateTemplateWithOverrides
[source, go]
----
func (p *Producer) CreateTemplateWithOverrides() *Template
----

CreateTemplateWithOverrides creates a new instance of _Template_
and add the possible _Provider.overrides_ into it.

===== Generate
[source, go]
----
func (p *Producer) Generate()
----

Generate will execute the generation of the documentation

===== createWriter
[source, go]
----
func (p *Producer) createWriter() io.Writer
----





=== writer
[source, go]
----
type writer struct {
    w    io.Writer
}
----



==== w io.Writer





=== TemplateAndText
[source, go]
----
type TemplateAndText struct {
    Text        string
    Template    *template.Template
}
----

TemplateAndText is a wrapper of _template.Template_
but also includes the original text representation
of the template and not just the parsed tree.

==== Text string
Text is the actual template that got parsed by _template.Template_.

==== Template *template.Template
Template is the instance of the parsed _Text_ including functions.




=== Template
[source, go]
----
type Template struct {
    Templates    map[string]*TemplateAndText
}
----

Template is handling all templates and actions
to perform.

==== Templates map[string]*TemplateAndText
Templates to use when rendering documentation


==== Receivers

===== NewContext
[source, go]
----
func (t *Template) NewContext(f *goparser.GoFile) *TemplateContext
----

NewContext creates a new context to be used for rendering.

===== NewContextWithConfig
[source, go]
----
func (t *Template) NewContextWithConfig(
    f *goparser.GoFile,
    p *goparser.GoPackage,
    config *TemplateContextConfig) *TemplateContext
----

NewContextWithConfig creates a new context with configuration.

If configuration is nil, it will use default configuration.



=== TemplateContext
[source, go]
----
type TemplateContext struct {
    creator            *Template
    File               *goparser.GoFile
    Package            *goparser.GoPackage
    Module             *goparser.GoModule
    Struct             *goparser.GoStruct
    Function           *goparser.GoStructMethod
    Interface          *goparser.GoInterface
    TypeDefVar         *goparser.GoCustomType
    TypeDefFunc        *goparser.GoMethod
    VarAssignment      *goparser.GoAssignment
    ConstAssignment    *goparser.GoAssignment
    Config             *TemplateContextConfig
    Index              *IndexConfig
    Receiver           []*goparser.GoStructMethod
    Docs               map[string]string
}
----

TemplateContext is a context that may be used to render
a GoFile. Depending on the template, different fields are
populated in this struct.

==== creator *Template
creator is the template created this context.

==== File *goparser.GoFile
File is the complete file. This property is always present.

For package and imports, this is the only one to access

==== Package *goparser.GoPackage
Package where the `File` resides under. Most of the time
is `Package` and `File` the same since rendering is done
on package level.

==== Module *goparser.GoModule
Module for the context

==== Struct *goparser.GoStruct
Struct is the current GoStruct

==== Function *goparser.GoStructMethod
Function is the current function

==== Interface *goparser.GoInterface
Interface is the current GoInterface

==== TypeDefVar *goparser.GoCustomType
TypeDefVar is current variable type definition

==== TypeDefFunc *goparser.GoMethod
TypedefFun is current function type defintion.

==== VarAssignment *goparser.GoAssignment
VarAssignment is current variable assignment using var keyword

==== ConstAssignment *goparser.GoAssignment
ConstAssignment is current const definition and value assignment

==== Config *TemplateContextConfig
Config contains the configuration of this context.

==== Index *IndexConfig
Index is configuration to render the index template

==== Receiver []*goparser.GoStructMethod
Receiver is the current receivers to be rendered.

==== Docs map[string]string
Docs is a map that contains filepaths to various asciidoc documents
that can be included.

.Available Documents
|===
|Name |Comment

|package-overview
|This is a absolute path to a overview document for the current package.

|===


==== Receivers

===== Clone
[source, go]
----
func (t *TemplateContext) Clone(clean bool) *TemplateContext
----

Clone will clone the context.

===== DefaultIndexConfig
[source, go]
----
func (t *TemplateContext) DefaultIndexConfig(overrides string) *IndexConfig
----

DefaultIndexConfig creates a default index configuration that may be used in RenderIndex
function.

The overrides are specifies as a json document, only properties set in the JSON document will
override default IndexConfig.

===== Creator
[source, go]
----
func (t *TemplateContext) Creator() *Template
----

Creator returns the template created this context.

===== RenderPackage
[source, go]
----
func (t *TemplateContext) RenderPackage(wr io.Writer) *TemplateContext
----

RenderPackage will render the package defintion onto the provided writer.

Depending on if a package overview asciidoc document is found it will prioritize that before
the go package documentation. Hence it will use either _PackageTemplate_ or
_PackageIncludeOverviewTemplate_ depending if found a ascii doc overview document.

===== RenderImports
[source, go]
----
func (t *TemplateContext) RenderImports(wr io.Writer) *TemplateContext
----

RenderImports will render the imports section onto the provided writer.

===== RenderFunctions
[source, go]
----
func (t *TemplateContext) RenderFunctions(wr io.Writer) *TemplateContext
----

RenderFunctions will render all functions for GoFile/GoPackage onto the provided writer.

===== RenderReceiverFunctions
[source, go]
----
func (t *TemplateContext) RenderReceiverFunctions(wr io.Writer, receiver string) *TemplateContext
----

RenderReceiverFunctions will render all receiver functions for a given receiver, albeit a custom type or a struct.

===== RenderFunction
[source, go]
----
func (t *TemplateContext) RenderFunction(wr io.Writer, f *goparser.GoStructMethod) *TemplateContext
----

RenderFunction will render a single function section onto the provided writer.

===== RenderInterfaces
[source, go]
----
func (t *TemplateContext) RenderInterfaces(wr io.Writer) *TemplateContext
----

RenderInterfaces will render all interfaces for GoFile/GoPackage onto the provided writer.

===== RenderInterface
[source, go]
----
func (t *TemplateContext) RenderInterface(wr io.Writer, i *goparser.GoInterface) *TemplateContext
----

RenderInterface will render a single interface section onto the provided writer.

===== RenderStructs
[source, go]
----
func (t *TemplateContext) RenderStructs(wr io.Writer) *TemplateContext
----

RenderStructs will render all structs for GoFile/GoPackage onto the provided writer.

===== RenderStruct
[source, go]
----
func (t *TemplateContext) RenderStruct(wr io.Writer, s *goparser.GoStruct) *TemplateContext
----

RenderStruct will render a single struct section onto the provided writer.

===== RenderVarTypeDefs
[source, go]
----
func (t *TemplateContext) RenderVarTypeDefs(wr io.Writer) *TemplateContext
----

RenderVarTypeDefs will render all variable type definitions for GoFile/GoPackage onto the provided writer.

===== RenderVarTypeDef
[source, go]
----
func (t *TemplateContext) RenderVarTypeDef(wr io.Writer, td *goparser.GoCustomType) *TemplateContext
----

RenderVarTypeDef will render a single variable typedef section onto the provided writer.

===== RenderVarDeclarations
[source, go]
----
func (t *TemplateContext) RenderVarDeclarations(wr io.Writer) *TemplateContext
----

RenderVarDeclarations will render all variable declarations for GoFile/GoPackage onto the provided writer.

===== RenderVarDeclaration
[source, go]
----
func (t *TemplateContext) RenderVarDeclaration(wr io.Writer, a *goparser.GoAssignment) *TemplateContext
----

RenderVarDeclaration will render a single variable declaration section onto the provided writer.

===== RenderConstDeclarations
[source, go]
----
func (t *TemplateContext) RenderConstDeclarations(wr io.Writer) *TemplateContext
----

RenderConstDeclarations will render all const declarations for GoFile/GoPackage onto the provided writer.

===== RenderConstDeclaration
[source, go]
----
func (t *TemplateContext) RenderConstDeclaration(wr io.Writer, a *goparser.GoAssignment) *TemplateContext
----

RenderConstDeclaration will render a single const declaration section onto the provided writer.

===== RenderTypeDefFuncs
[source, go]
----
func (t *TemplateContext) RenderTypeDefFuncs(wr io.Writer) *TemplateContext
----

RenderTypeDefFuncs will render all type definitions for GoFile/GoPackage onto the provided writer.

===== RenderTypeDefFunc
[source, go]
----
func (t *TemplateContext) RenderTypeDefFunc(wr io.Writer, td *goparser.GoMethod) *TemplateContext
----

RenderTypeDefFunc will render a single typedef section onto the provided writer.

===== RenderIndex
[source, go]
----
func (t *TemplateContext) RenderIndex(wr io.Writer, ic *IndexConfig) *TemplateContext
----

RenderIndex will render the complete index page for all GoFiles/GoPackages onto the provided writer.

If nil is provided as IndexConfig it will use the default config.

===== resolvePackageOverview
[source, go]
----
func (t *TemplateContext) resolvePackageOverview() string
----

resolvePackageOverview will search the list of inclusion try to resolve any file and return the filepath.

If it fails, an empty string is returned. This uses the _TemplateConfig.PackageOverviewPaths_
list to resolve the data. The first hit of the absolute filepath will be returned.



=== TemplateContextConfig
[source, go]
----
type TemplateContextConfig struct {
    IncludeMethodCode       bool
    PackageOverviewPaths    []string
}
----

TemplateContextConfig contains configuration parameters how templates
renders the content and the TemplateContexts behaves.

==== IncludeMethodCode bool
IncludeMethodCode determines if the code is included in the documentation or not.
Default not included.

==== PackageOverviewPaths []string
PackageOverviewPaths paths to search for package overview relative the package path.

It searches the order as they appear in this array until found, then terminates. It is
not possible to have two _*.adoc_ inclusions.

.Example Paths
|===
|Example |Comment

|overview.adoc
|This expects the overview.adoc to be in the same folders as the other go files in the package.

|_design/package-summary.adoc
|This tells the renderer to look for _package-summary.adoc_ in _package path/_design_ folder.

|===




=== IndexConfig
[source, go]
----
type IndexConfig struct {
    Title          string
    Version        string
    AuthorName     string
    AuthorEmail    string
    Highlighter    string
    TocTitle       string
    TocLevels      int
    ImageDir       string
    HomePage       string
    DocType        string
}
----

IndexConfig is configuration to use when generating index template

==== Title string
Title is the title of the index document, if omitted it uses the module name (if present)

==== Version string
Version is the version stamped as version attribute, if omitted it uses module version (if any)

==== AuthorName string
AuthorName is the full name of the author e.g. Mario Toffia (if none is set, default to current user)

==== AuthorEmail string
AuthorEmail is the email of the author e.g. mario.toffia@bullen.se

==== Highlighter string
Highlighter is the source highlighter to use - default is 'highlightjs'

==== TocTitle string
TocTitle is the title of the generated table of contents (if set a toc is generated)
Default is 'Table of Contents', hence by default a TOC is generated.

==== TocLevels int
TocLevels determines how many levels shall it include, default 3

==== ImageDir string
A fully qualified or relative output path to where to search for images

==== HomePage string
HomePage is the url to homepage

==== DocType string
DocType determines the document type, default is book





== Variable Typedefinitions

=== TemplateType
[source, go]
----
type TemplateType string
----
TemplateType specifies the template type


=== Constants
[source, go]
----
const (
    IndexTemplate                 TemplateType = "index"
    PackageTemplate               TemplateType = "package"
    ImportTemplate                TemplateType = "import"
    FunctionsTemplate             TemplateType = "functions"
    FunctionTemplate              TemplateType = "function"
    InterfacesTemplate            TemplateType = "interfaces"
    InterfaceTemplate             TemplateType = "interface"
    StructsTemplate               TemplateType = "structs"
    StructTemplate                TemplateType = "struct"
    CustomVarTypeDefsTemplate     TemplateType = "typedefvars"
    CustomVarTypeDefTemplate      TemplateType = "typedefvar"
    CustomFuncTypeDefsTemplate    TemplateType = "typedeffuncs"
    CustomFuncTypeDefTemplate     TemplateType = "typedeffunc"
    VarDeclarationsTemplate       TemplateType = "vars"
    VarDeclarationTemplate        TemplateType = "var"
    ConstDeclarationsTemplate     TemplateType = "consts"
    ConstDeclarationTemplate      TemplateType = "const"
    ReceiversTemplate             TemplateType = "receivers"
)
----

=== IndexTemplate
[source, go]
----
IndexTemplate TemplateType = "index"
----
IndexTemplate is a template that binds all generated asciidoc files into one single index file
by referencing (or appending to this file).


=== PackageTemplate
[source, go]
----
PackageTemplate TemplateType = "package"
----
PackageTemplate specifies that the template is a package


=== ImportTemplate
[source, go]
----
ImportTemplate TemplateType = "import"
----
ImportTemplate specifies that the template renders a import


=== FunctionsTemplate
[source, go]
----
FunctionsTemplate TemplateType = "functions"
----
FunctionsTemplate is a template to render all functions for a given context (package, file)


=== FunctionTemplate
[source, go]
----
FunctionTemplate TemplateType = "function"
----
FunctionTemplate is a template to render a function


=== InterfacesTemplate
[source, go]
----
InterfacesTemplate TemplateType = "interfaces"
----
InterfacesTemplate is a template to render a all interface defintions for a given context (package, file)


=== InterfaceTemplate
[source, go]
----
InterfaceTemplate TemplateType = "interface"
----
InterfaceTemplate is a template to render a interface defintion


=== StructsTemplate
[source, go]
----
StructsTemplate TemplateType = "structs"
----
StructsTemplate specifies that the template renders all struct definitions for a given context (package, file)


=== StructTemplate
[source, go]
----
StructTemplate TemplateType = "struct"
----
StructTemplate specifies that the template renders a struct definition


=== CustomVarTypeDefsTemplate
[source, go]
----
CustomVarTypeDefsTemplate TemplateType = "typedefvars"
----
CustomVarTypeDefsTemplate is a template to render all variable type definitions for a given context (package, file)


=== CustomVarTypeDefTemplate
[source, go]
----
CustomVarTypeDefTemplate TemplateType = "typedefvar"
----
CustomVarTypeDefTemplate is a template to render a type definition of a variable


=== CustomFuncTypeDefsTemplate
[source, go]
----
CustomFuncTypeDefsTemplate TemplateType = "typedeffuncs"
----
CustomFuncTypeDefsTemplate is a template to render all function type definitions for a given context (package, file)


=== CustomFuncTypeDefTemplate
[source, go]
----
CustomFuncTypeDefTemplate TemplateType = "typedeffunc"
----
CustomFuncTypeDefTemplate is a template to render a function type definition


=== VarDeclarationsTemplate
[source, go]
----
VarDeclarationsTemplate TemplateType = "vars"
----
VarDeclarationsTemplate is a template to render all variable definitions for a given context (package, file)


=== VarDeclarationTemplate
[source, go]
----
VarDeclarationTemplate TemplateType = "var"
----
VarDeclarationTemplate is a template to render a variable definition


=== ConstDeclarationsTemplate
[source, go]
----
ConstDeclarationsTemplate TemplateType = "consts"
----
ConstDeclarationsTemplate is a template to render all const declaration entries for a given context (package, file)


=== ConstDeclarationTemplate
[source, go]
----
ConstDeclarationTemplate TemplateType = "const"
----
ConstDeclarationTemplate is a template to render a const declaration entry


=== ReceiversTemplate
[source, go]
----
ReceiversTemplate TemplateType = "receivers"
----
ReceiversTemplate is a template that renders receivers functions


== Variables

=== templateIndex
[source, go]
----
var templateIndex = `= {{ .Index.Title }}
{{- if .Index.AuthorName}}{{"\n"}}:author_name: {{.Index.AuthorName}}{{"\n"}}:author: {author_name}{{end}}
{{- if .Index.AuthorEmail}}{{"\n"}}:author_email: {{.Index.AuthorEmail}}{{"\n"}}:email: {author_email}{{end}}
:source-highlighter: {{ .Index.Highlighter }}
{{- if .Index.TocTitle}}{{"\n"}}:toc:{{"\n"}}:toc-title: {{ .Index.TocTitle }}{{"\n"}}:toclevels: {{ .Index.TocLevels }}{{end}}
:icons: font
{{- if .Index.ImageDir}}{{"\n"}}:imagesdir: {{.Index.ImageDir}}{{end}}
{{- if .Index.HomePage}}{{"\n"}}:homepage: {{.Index.HomePage}}{{end}}
:kroki-default-format: svg
:doctype: {{.Index.DocType}}

`
----



=== templatePackage
[source, go]
----
var templatePackage = `== {{if .File.FqPackage}}Package {{.File.FqPackage}}{{else}}{{.File.Decl}}{{end}}

{{if (index .Docs "package-overview")}}include::{{index .Docs "package-overview"}}[leveloffset=+1]{{"\n"}}{{else}}{{ .File.Doc }}{{end}}
`
----



=== templateImports
[source, go]
----
var templateImports = `=== Imports
[source, go]
----
{{ render . }}
----
{{range .File.Imports}}{{if .Doc }}{{"\n"}}==== Import _{{ .Path }}_{{"\n"}}{{ .Doc }}{{"\n"}}{{end}}{{end}}
`
----



=== templateFunctions
[source, go]
----
var templateFunctions = `== Functions

{{range .File.StructMethods}}
{{- if notreceiver $ .}}{{render $ .}}{{end}}
{{end}}
`
----



=== templateFunction
[source, go]
----
var templateFunction = `=== {{ .Function.Name }}
[source, go]
----
{{ .Function.Decl }}
----

{{ .Function.Doc }}
{{ if .Config.IncludeMethodCode }}{{"\n"}}[source, go]{{"\n"}}----{{"\n"}}{{ .Function.FullDecl }}{{"\n"}}----{{end}}
`
----



=== templateInterface
[source, go]
----
var templateInterface = `=== {{ .Interface.Name }}
[source, go]
----
{{.Interface.Decl}} {
{{- range .Interface.Methods}}
    {{tabifylast .Decl}}
{{- end}}
}
----
        
{{.Interface.Doc}}
{{range .Interface.Methods}}
==== {{.Decl}}
{{.Doc}}
{{end}}
`
----



=== templateInterfaces
[source, go]
----
var templateInterfaces = `== Interfaces

{{range .File.Interfaces}}
{{- render $ .}}
{{end}}
`
----



=== templateStruct
[source, go]
----
var templateStruct = `=== {{.Struct.Name}}
[source, go]
----
{{.Struct.Decl}} {
{{- range .Struct.Fields}}
    {{if .Nested}}{{.Nested.Name}}{{"\t"}}struct{{else}}{{tabify .Decl}}{{end}}
{{- end}}
}
----

{{.Struct.Doc}}
{{range .Struct.Fields}}{{if not .Nested}}
==== {{.Decl}}
{{.Doc}}
{{- end}}
{{end}}
{{range .Struct.Fields}}{{if .Nested}}{{render $ .Nested}}{{end}}{{end}}
{{if hasReceivers . .Struct.Name}}{{renderReceivers . .Struct.Name}}{{end}}
`
----



=== templateStructs
[source, go]
----
var templateStructs = `== Structs

{{range .File.Structs}}
{{- render $ .}}
{{end}}
`
----



=== templateReceivers
[source, go]
----
var templateReceivers = `==== Receivers
{{range .Receiver}}
===== {{.Name}}
[source, go]
----
{{ .Decl }}
----

{{.Doc}}
{{end}}
`
----



=== templateCustomTypeDefintion
[source, go]
----
var templateCustomTypeDefintion = `=== {{.TypeDefVar.Name}}
[source, go]
----
{{.TypeDefVar.Decl}}
----
{{.TypeDefVar.Doc}}
`
----



=== templateCustomTypeDefintions
[source, go]
----
var templateCustomTypeDefintions = `== Variable Typedefinitions

{{range .File.CustomTypes}}
{{- render $ .}}
{{end}}
`
----



=== templateVarAssignment
[source, go]
----
var templateVarAssignment = `=== {{.VarAssignment.Name}}
[source, go]
----
{{.VarAssignment.FullDecl}}
----
{{.VarAssignment.Doc}}
`
----



=== templateVarAssignments
[source, go]
----
var templateVarAssignments = `== Variables
{{range .File.VarAssignments}}
{{render $ .}}
{{end}}
`
----



=== templateConstAssignment
[source, go]
----
var templateConstAssignment = `=== {{.ConstAssignment.Name}}
[source, go]
----
{{.ConstAssignment.Decl}}
----
{{.ConstAssignment.Doc}}
`
----



=== templateConstAssignments
[source, go]
----
var templateConstAssignments = `=== Constants
[source, go]
----
const (
    {{- range .File.ConstAssignments}}
    {{tabify .Decl}}
    {{- end}}
)
----
{{range .File.ConstAssignments}}
{{render $ .}}
{{end}}
`
----



=== templateCustomFuncDefintion
[source, go]
----
var templateCustomFuncDefintion = `=== {{.TypeDefFunc.Name}}
[source, go]
----
{{.TypeDefFunc.Decl}}
----
{{.TypeDefFunc.Doc}}
`
----



=== templateCustomFuncDefintions
[source, go]
----
var templateCustomFuncDefintions = `== Function Definitions

{{range .File.CustomFuncs}}
{{render $ .}}
{{end}}
`
----



== Functions

=== NewProducer
[source, go]
----
func NewProducer() *Producer
----

NewProducer creates a new instance of a producer.
















=== TestGenerateWorkspaceToString
[source, go]
----
func TestGenerateWorkspaceToString(t *testing.T)
----








=== NewTemplate
[source, go]
----
func NewTemplate() *Template
----

NewTemplate creates a new set of templates to be used


=== NewTemplateWithOverrides
[source, go]
----
func NewTemplateWithOverrides(overrides map[string]string) *Template
----

NewTemplateWithOverrides creates a new template with the ability to easily
override defaults.




=== createTemplate
[source, go]
----
func createTemplate(name TemplateType, str string, overrides map[string]string, fm template.FuncMap) *TemplateAndText
----

createTemplate will create a template named name and parses the str
as template. If fails it will panic with the parse error.

If name is found in override map it will use that string to parse the template
instead of the provided str.


=== dummyModule
[source, go]
----
func dummyModule() *goparser.GoModule
----




=== TestRenderPackageWithModule
[source, go]
----
func TestRenderPackageWithModule(t *testing.T)
----




=== TestRenderPackageWithoutModule
[source, go]
----
func TestRenderPackageWithoutModule(t *testing.T)
----




=== TestRenderImports
[source, go]
----
func TestRenderImports(t *testing.T)
----




=== TestRenderSingleFunction
[source, go]
----
func TestRenderSingleFunction(t *testing.T)
----




=== TestRenderSingleFunctionWithCode
[source, go]
----
func TestRenderSingleFunctionWithCode(t *testing.T)
----




=== TestRenderFunctions
[source, go]
----
func TestRenderFunctions(t *testing.T)
----




=== TestRenderSingleInterface
[source, go]
----
func TestRenderSingleInterface(t *testing.T)
----




=== TestRenderMultipleInterfaces
[source, go]
----
func TestRenderMultipleInterfaces(t *testing.T)
----




=== TestRenderSingleStruct
[source, go]
----
func TestRenderSingleStruct(t *testing.T)
----




=== TestRenderMultipleStructs
[source, go]
----
func TestRenderMultipleStructs(t *testing.T)
----




=== TestRenderNestedAnonymousStruct
[source, go]
----
func TestRenderNestedAnonymousStruct(t *testing.T)
----




=== TestRenderNestedKnownStruct
[source, go]
----
func TestRenderNestedKnownStruct(t *testing.T)
----




=== TestRenderSingleVarTypeDef
[source, go]
----
func TestRenderSingleVarTypeDef(t *testing.T)
----




=== TestRenderMultipleVarTypeDefs
[source, go]
----
func TestRenderMultipleVarTypeDefs(t *testing.T)
----




=== TestRenderSingleVarDeclaration
[source, go]
----
func TestRenderSingleVarDeclaration(t *testing.T)
----




=== TestRenderMultipleVarDeclarations
[source, go]
----
func TestRenderMultipleVarDeclarations(t *testing.T)
----




=== TestRenderSingleConstDeclaration
[source, go]
----
func TestRenderSingleConstDeclaration(t *testing.T)
----




=== TestRenderMultipleConstDeclarations
[source, go]
----
func TestRenderMultipleConstDeclarations(t *testing.T)
----




=== TestRenderSingleTypeDefFunc
[source, go]
----
func TestRenderSingleTypeDefFunc(t *testing.T)
----




=== TestRenderMultipleTypeDefFuncs
[source, go]
----
func TestRenderMultipleTypeDefFuncs(t *testing.T)
----




=== TestRenderIndexWithDefaults
[source, go]
----
func TestRenderIndexWithDefaults(t *testing.T)
----




=== TestRenderIndexWithAllSet
[source, go]
----
func TestRenderIndexWithAllSet(t *testing.T)
----




=== TestStructReceiverFunction
[source, go]
----
func TestStructReceiverFunction(t *testing.T)
----


























=== dirExists
[source, go]
----
func dirExists(dir string) bool
----




=== fileExists
[source, go]
----
func fileExists(filepath string) bool
----





== Package github.com/mariotoffia/goasciidoc/goparser

Package goparser was taken from an open source project (https://github.com/zpatrick/go-parser) by zpatrick. Since it seemed
that he had abandon it, I've integrated it into this project (and extended it).

=== Imports
[source, go]
----
import (
    "fmt"
    "os"
    "reflect"
    "sort"
    "strings"
    "testing"
    "github.com/stretchr/testify/assert"
    "go/ast"
    "go/parser"
    "go/token"
    "go/types"
    "golang.org/x/mod/modfile"
    "io/ioutil"
    "path/filepath"
)
----

== Interfaces

=== Resolver
[source, go]
----
type Resolver interface {
}
----
        
Resolver pure purpose is to resolve `GoFile`, `GoStructMethod` to
`GoTag` and all other types in between.



== Structs

=== GoFile
[source, go]
----
type GoFile struct {
    Module              *GoModule
    Package             string
    FqPackage           string
    FilePath            string
    Doc                 string
    Decl                string
    ImportFullDecl      string
    Structs             []*GoStruct
    Interfaces          []*GoInterface
    Imports             []*GoImport
    StructMethods       []*GoStructMethod
    CustomTypes         []*GoCustomType
    CustomFuncs         []*GoMethod
    VarAssignments      []*GoAssignment
    ConstAssignments    []*GoAssignment
}
----

GoFile represents a complete file

==== Module *GoModule


==== Package string
Package is the single package name where as FqPackage is the
fully qualified package (if Module) has been set.

==== FqPackage string
FqPackage is the fully qualified package name (if Module field)
is set to calculate the fq package name

==== FilePath string


==== Doc string


==== Decl string


==== ImportFullDecl string


==== Structs []*GoStruct


==== Interfaces []*GoInterface


==== Imports []*GoImport


==== StructMethods []*GoStructMethod


==== CustomTypes []*GoCustomType


==== CustomFuncs []*GoMethod


==== VarAssignments []*GoAssignment


==== ConstAssignments []*GoAssignment



==== Receivers

===== FindMethodsByReceiver
[source, go]
----
func (g *GoFile) FindMethodsByReceiver(receiver string) []*GoStructMethod
----

FindMethodsByReceiver searches the file / package after struct and custom type receiver
methods that matches the _receiver_ name.

===== ImportPath
[source, go]
----
func (g *GoFile) ImportPath() (string, error)
----

ImportPath resolves the import path.

===== DeclImports
[source, go]
----
func (g *GoFile) DeclImports() string
----

DeclImports emits the imports



=== GoImport
[source, go]
----
type GoImport struct {
    File    *GoFile
    Doc     string
    Name    string
    Path    string
}
----

GoImport represents a import of a package

==== File *GoFile


==== Doc string


==== Name string


==== Path string



==== Receivers

===== Prefix
[source, go]
----
func (g *GoImport) Prefix() string
----

Prefix is for an import - guess what prefix will be used
in type declarations.  For examples:
   "strings" -> "strings"
   "net/http/httptest" -> "httptest"
Libraries where the package name does not match
will be mis-identified.



=== GoStructMethod
[source, go]
----
type GoStructMethod struct {
    GoMethod
    Receivers    []string
}
----

GoStructMethod is a GoMethod but has receivers and is positioned on a struct or custom type.

==== GoMethod


==== Receivers []string





=== GoMethod
[source, go]
----
type GoMethod struct {
    File        *GoFile
    Name        string
    Doc         string
    Decl        string
    FullDecl    string
    Params      []*GoType
    Results     []*GoType
}
----

GoMethod is a method on a struct, custom type, interface or just plain function

==== File *GoFile


==== Name string


==== Doc string


==== Decl string


==== FullDecl string


==== Params []*GoType


==== Results []*GoType





=== GoModule
[source, go]
----
type GoModule struct {
    File         *modfile.File
    FilePath     string
    Base         string
    Name         string
    Version      string
    GoVersion    string
}
----

GoModule is a simple representation of a go.mod

==== File *modfile.File
File is the actual parsed go.mod file

==== FilePath string
FilePath is the filepath to the go module

==== Base string
Base is where all other packages are relative to.

This is usually the directory to the File field since
go.mod is usually in root project folder.

==== Name string
Name of the module e.g. github.com/mariotoffia/goasciidoc

==== Version string
Version of this module

==== GoVersion string
GoVersion specifies the required go version


==== Receivers

===== ResolvePackage
[source, go]
----
func (gm *GoModule) ResolvePackage(path string) string
----

ResolvePackage wil try to resolve the full package path
bases on this module and the provided path.

If it fails, it returns an empty string.



=== GoPackage
[source, go]
----
type GoPackage struct {
    GoFile
    Files    []*GoFile
}
----

GoPackage is a aggregation of all GoFiles in a single
package for ease of access.

==== GoFile


==== Files []*GoFile
Files are all files in current package.




=== GoTag
[source, go]
----
type GoTag struct {
    File     *GoFile
    Field    *GoField
    Value    string
}
----

GoTag is a tag on a struct field

==== File *GoFile


==== Field *GoField


==== Value string



==== Receivers

===== Get
[source, go]
----
func (g *GoTag) Get(key string) string
----

Get returns a struct tag with the specified name e.g. json



=== ParseConfig
[source, go]
----
type ParseConfig struct {
    Test          bool
    Internal      bool
    UnderScore    bool
    Module        *GoModule
}
----

ParseConfig to use when invoking ParseAny, ParseSingleFileWalker, and
ParseSinglePackageWalker.

==== Test bool
Test denotes if test files (ending with _test.go) should be included or not
(default not included)

==== Internal bool
Internal determines if internal folders are included or not (default not)

==== UnderScore bool
UnderScore, when set to true it will include directories beginning with _

==== Module *GoModule
Optional module to resolve fully qualified package paths




=== ResolverImpl
[source, go]
----
type ResolverImpl struct {
    module       *GoModule
    resolvers    map[string] /*module name*/ Resolver
    config       ParseConfig
    filepath     string
}
----

ResolverImpl is the implementation of a `Resolver` where it operarates on
a `GoModule` level.

==== module *GoModule
module is the resolvers workspace.

It may have sub-modules through contained `Resolver` instances.

==== resolvers map[string] /*module name*/ Resolver
resolvers is a map containing `Resolver` for each `GoModule` that this _module_
references and makes use of.

==== config ParseConfig
config is the configuration that this `Resolver` adheres to.

==== filepath string
Fully qualified filepath to this module (where _go.mod_ resides).


==== Receivers

===== resolveModule
[source, go]
----
func (r *ResolverImpl) resolveModule(fp string) Resolver
----



===== loadAll
[source, go]
----
func (r *ResolverImpl) loadAll() error
----





=== GoAssignment
[source, go]
----
type GoAssignment struct {
    File        *GoFile
    Name        string
    Doc         string
    Decl        string
    FullDecl    string
}
----

GoAssignment represents a single var assignment e.g. var pelle = 10

==== File *GoFile


==== Name string


==== Doc string


==== Decl string
Decl will be the same if multi var assignment on same row e.g. var pelle, lisa = 10, 19
then both pelle and list will have 'var pelle, lisa = 10, 19' as Decl

==== FullDecl string





=== GoCustomType
[source, go]
----
type GoCustomType struct {
    File    *GoFile
    Name    string
    Doc     string
    Type    string
    Decl    string
}
----

GoCustomType is a custom type definition

==== File *GoFile


==== Name string


==== Doc string


==== Type string


==== Decl string





=== GoInterface
[source, go]
----
type GoInterface struct {
    File        *GoFile
    Doc         string
    Decl        string
    FullDecl    string
    Name        string
    Methods     []*GoMethod
}
----

GoInterface specifies a interface definition

==== File *GoFile


==== Doc string


==== Decl string


==== FullDecl string


==== Name string


==== Methods []*GoMethod





=== GoType
[source, go]
----
type GoType struct {
    File          *GoFile
    Name          string
    Type          string
    Underlying    string
    Inner         []*GoType
}
----

GoType represents a go type such as a array, map, custom type etc.

==== File *GoFile


==== Name string


==== Type string


==== Underlying string


==== Inner []*GoType





=== GoStruct
[source, go]
----
type GoStruct struct {
    File        *GoFile
    Doc         string
    Decl        string
    FullDecl    string
    Name        string
    Fields      []*GoField
}
----

GoStruct represents a struct

==== File *GoFile


==== Doc string


==== Decl string


==== FullDecl string


==== Name string


==== Fields []*GoField





=== GoField
[source, go]
----
type GoField struct {
    File      *GoFile
    Struct    *GoStruct
    Doc       string
    Decl      string
    Name      string
    Type      string
    Tag       *GoTag
    Nested    *GoStruct
}
----

GoField is a field in a file or struct

==== File *GoFile


==== Struct *GoStruct


==== Doc string


==== Decl string


==== Name string


==== Type string


==== Tag *GoTag


==== Nested *GoStruct






== Function Definitions


=== ParseSingleFileWalkerFunc
[source, go]
----
type ParseSingleFileWalkerFunc func(*GoFile) error
----
ParseSingleFileWalkerFunc is used in conjuction with ParseSingleFileWalker.

If the ParseSingleFileWalker is returning an error, parsing will immediately stop
and the error is returned.


=== ParseSinglePackageWalkerFunc
[source, go]
----
type ParseSinglePackageWalkerFunc func(*GoPackage) error
----
ParseSinglePackageWalkerFunc is used in conjuction with ParseSinglePackageWalker.

If the ParseSinglePackageWalker is returning an error, parsing will immediately stop
and the error is returned.


== Functions


=== contains
[source, go]
----
func contains(name string, arr []string) bool
----

contains checks if any in the _arr_ matches the _name_. If found
`true` is returned, otherwise `false` is returned.




=== TestImportBaseShallComeFirst
[source, go]
----
func TestImportBaseShallComeFirst(t *testing.T)
----






=== NewModule
[source, go]
----
func NewModule(path string) (*GoModule, error)
----

NewModule creates a new module from go.mod pointed out in the
in param path parameter.


=== NewModuleFromBuff
[source, go]
----
func NewModuleFromBuff(path string, buff []byte) (*GoModule, error)
----

NewModuleFromBuff creates a new module from the buff specified in
the buff parameter and states that the buff is read from path.


=== getPwd
[source, go]
----
func getPwd() string
----




=== TestModuleBasePathIsTakenFromPathParam
[source, go]
----
func TestModuleBasePathIsTakenFromPathParam(t *testing.T)
----




=== TestParseWithOnlyModuleLine
[source, go]
----
func TestParseWithOnlyModuleLine(t *testing.T)
----




=== TestParseWithNoModuleLineMustFail
[source, go]
----
func TestParseWithNoModuleLineMustFail(t *testing.T)
----




=== TestParseModuleNameGoVersionAndRequires
[source, go]
----
func TestParseModuleNameGoVersionAndRequires(t *testing.T)
----





=== parseFile
[source, go]
----
func parseFile(mod *GoModule, path string, source []byte, file *ast.File, fset *token.FileSet, files []*ast.File) (*GoFile, error)
----




=== buildVarAssignment
[source, go]
----
func buildVarAssignment(file *GoFile, genDecl *ast.GenDecl, valueSpec *ast.ValueSpec, source []byte) []*GoAssignment
----




=== extractDocs
[source, go]
----
func extractDocs(doc *ast.CommentGroup) string
----




=== buildGoImport
[source, go]
----
func buildGoImport(spec *ast.ImportSpec, file *GoFile) *GoImport
----




=== buildGoInterface
[source, go]
----
func buildGoInterface(source []byte, file *GoFile, info *types.Info, typeSpec *ast.TypeSpec, interfaceType *ast.InterfaceType) *GoInterface
----




=== buildMethodList
[source, go]
----
func buildMethodList(file *GoFile, info *types.Info, fieldList []*ast.Field, source []byte) []*GoMethod
----




=== buildStructMethod
[source, go]
----
func buildStructMethod(file *GoFile, info *types.Info, funcDecl *ast.FuncDecl, source []byte) *GoStructMethod
----




=== buildReceiverList
[source, go]
----
func buildReceiverList(info *types.Info, fieldList *ast.FieldList, source []byte) []string
----




=== buildTypeList
[source, go]
----
func buildTypeList(file *GoFile, info *types.Info, fieldList *ast.FieldList, source []byte) []*GoType
----




=== getNames
[source, go]
----
func getNames(field *ast.Field) []string
----




=== getTypeString
[source, go]
----
func getTypeString(expr ast.Expr, source []byte) string
----




=== getUnderlyingTypeString
[source, go]
----
func getUnderlyingTypeString(info *types.Info, expr ast.Expr) string
----




=== copyType
[source, go]
----
func copyType(goType *GoType) *GoType
----




=== buildType
[source, go]
----
func buildType(file *GoFile, info *types.Info, expr ast.Expr, source []byte) *GoType
----




=== buildGoStruct
[source, go]
----
func buildGoStruct(source []byte, file *GoFile, info *types.Info, structName string, structType *ast.StructType) *GoStruct
----




=== ParseSingleFile
[source, go]
----
func ParseSingleFile(mod *GoModule, path string) (*GoFile, error)
----

ParseSingleFile parses a single file at the same time

If a module is passed, it will calculate package relative to that


=== ParseFiles
[source, go]
----
func ParseFiles(mod *GoModule, paths ...string) ([]*GoFile, error)
----

ParseFiles parses one or more files


=== ParseInlineFile
[source, go]
----
func ParseInlineFile(mod *GoModule, path, code string) (*GoFile, error)
----

ParseInlineFile will parse the code provided.

To simulate package names set the path to some level
equal to or greater than GoModule.Base. Otherwise just
set path "" to ignore.


=== ParseAny
[source, go]
----
func ParseAny(config ParseConfig, paths ...string) ([]*GoFile, error)
----

ParseAny parses one or more directories (recursively) for go files. It is also possible
to add files along with directories (or just files).

It is possible to use relative paths or fully qualified paths along with '.'
for current directory. The paths are stat:ed so it will check if it is a file
or directory and do accordingly. If file it will ignore configuration and blindly
accept the file.

The example below parses from current directory down recursively and skips
test, internal and underscore directories.
Example: ParseAny(ParseConfig{}, ".")

Next example will recursively add go files from src and one single test.go under
directory dummy (both relative current directory).
Example: ParseAny(ParseConfig{}, "./src", "./dummy/test.go")


=== ParseSingleFileWalker
[source, go]
----
func ParseSingleFileWalker(config ParseConfig, process ParseSingleFileWalkerFunc, paths ...string) error
----

ParseSingleFileWalker is same as ParseAny, except that it will be fed one GoFile at the
time and thus consume much less memory.

It uses GetFilePaths and hence, the traversal is in sorted order, directory by directory.


=== ParseSinglePackageWalker
[source, go]
----
func ParseSinglePackageWalker(config ParseConfig, process ParseSinglePackageWalkerFunc, paths ...string) error
----

ParseSinglePackageWalker is same as ParseAny, except that it will be fed one GoPackage at the
time and thus consume much less memory.

It uses GetFilePaths and hence, the traversal is in sorted order, directory by directory. It will
bundle all files in same directory and assign those to a GoPackage before invoking ParseSinglePackageWalkerFunc


=== GetFilePaths
[source, go]
----
func GetFilePaths(config ParseConfig, paths ...string) ([]string, error)
----

GetFilePaths will iterate directories (recursively) and add explicit files
in the paths.

It is possible to use relative paths or fully qualified paths along with '.'
for current directory. The paths are stat:ed so it will check if it is a file
or directory and do accordingly. If file it will ignore configuration and blindly
accept the file.


=== dummyModule
[source, go]
----
func dummyModule() *GoModule
----




=== TestParsePackageDoc
[source, go]
----
func TestParsePackageDoc(t *testing.T)
----




=== TestParseImportDoc
[source, go]
----
func TestParseImportDoc(t *testing.T)
----




=== TestParsePrivateFunction
[source, go]
----
func TestParsePrivateFunction(t *testing.T)
----




=== TestParseExportedFunction
[source, go]
----
func TestParseExportedFunction(t *testing.T)
----




=== TestParseMultilineCppStyleComment
[source, go]
----
func TestParseMultilineCppStyleComment(t *testing.T)
----




=== TestParseMultilineCStyleComment
[source, go]
----
func TestParseMultilineCStyleComment(t *testing.T)
----




=== TestInterfaceDefinitionComment
[source, go]
----
func TestInterfaceDefinitionComment(t *testing.T)
----




=== TestInterfaceMethodComment
[source, go]
----
func TestInterfaceMethodComment(t *testing.T)
----




=== TestStructDefinitionComment
[source, go]
----
func TestStructDefinitionComment(t *testing.T)
----




=== TestStructFieldComment
[source, go]
----
func TestStructFieldComment(t *testing.T)
----




=== TestNestedAnonymousStructDefinitionComment
[source, go]
----
func TestNestedAnonymousStructDefinitionComment(t *testing.T)
----




=== TestNestedStructDefinitionComment
[source, go]
----
func TestNestedStructDefinitionComment(t *testing.T)
----




=== TestCustomTypePrimitive
[source, go]
----
func TestCustomTypePrimitive(t *testing.T)
----




=== TestCustomTypeStructType
[source, go]
----
func TestCustomTypeStructType(t *testing.T)
----




=== TestCustomFunctionDefinition
[source, go]
----
func TestCustomFunctionDefinition(t *testing.T)
----




=== TestSingleLineMultiVarDeclaration
[source, go]
----
func TestSingleLineMultiVarDeclaration(t *testing.T)
----




=== TestPrimitiveConst
[source, go]
----
func TestPrimitiveConst(t *testing.T)
----




=== TestMultiplePrimitiveConst
[source, go]
----
func TestMultiplePrimitiveConst(t *testing.T)
----




=== TestCustomTypeConst
[source, go]
----
func TestCustomTypeConst(t *testing.T)
----




=== TestVarInsideCodeIsDiscarded
[source, go]
----
func TestVarInsideCodeIsDiscarded(t *testing.T)
----




=== TestParseStructFunction
[source, go]
----
func TestParseStructFunction(t *testing.T)
----




=== TestFunctionBoundToStruct
[source, go]
----
func TestFunctionBoundToStruct(t *testing.T)
----




=== NewResolver
[source, go]
----
func NewResolver(config ParseConfig, filepath string) Resolver
----

NewResolver creates a new `Resolver` from the filepath to the _go.mod_ file
or directory where _go.mod_ resides.





== Package github.com/mariotoffia/goasciidoc/internal/utils


=== Imports
[source, go]
----
import (
    "fmt"
    "io"
    "os"
    "io/ioutil"
    "path/filepath"
)
----

== Functions

=== CopyFile
[source, go]
----
func CopyFile(src, dst string) (err error)
----

CopyFile copies the contents of the file named src to the file named
by dst. The file will be created if it does not already exist. If the
destination file exists, all it's contents will be replaced by the contents
of the source file. The file mode will be copied from the source and
the copied data is synced/flushed to stable storage.


=== TempCopyDir
[source, go]
----
func TempCopyDir(src, prefix string) (string /*tmp*/, error)
----

TempCopyDir will copy the src directory recurisvely onto a newly created
temporary directory. If succeeds it returns the temp directory for use.

use defer os.RemoveAll(tmpdir) when done to cleanup.


=== CopyDir
[source, go]
----
func CopyDir(src string, dst string, exists bool) (err error)
----

CopyDir recursively copies a directory tree, attempting to preserve permissions.
Source directory must exist, destination directory must *not* exist.
Symlinks are ignored and skipped.

If exists is set to true, it won't fail if dst already exists.



